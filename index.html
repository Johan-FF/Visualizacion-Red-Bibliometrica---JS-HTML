<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1 id="grupo"></h1>
  <article class="contenedor"></article>
</body>
<style>
  body{
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }
  #grupo{
    text-align: center;
    padding-bottom: 0px;
    margin-bottom: 0px;
  }
  .contenedor{
    height: 550px;
    width: 550px;
    background-color: aqua;
    position: relative;
  }
  .nodo:hover {
    opacity: 75%;
  }
</style>
<script>
  // Asignación del título
  // es decir, el grupo de investigación seleccionado.

  let grupo = localStorage.getItem("grupo");
  if(!grupo)
    window.close();

  let titulo = document.querySelector("#grupo");
  if(!titulo)
    window.location.reload();

  titulo.innerHTML = grupo.toString();
</script>
<script>
  // Constantes de red bibliométrica
  const IDEAS = {
    "network": {
      "items": [
        {
          "id": 90,
          "label": "communication and networks",
          "x": 0.5069,
          "y": 0.2174,
          "cluster": 2,
          "weights": {
            "Links": 5.0000,
            "Total link strength": 26.0000,
            "Occurrences": 18.0000
          },
          "scores": {
            "Avg. pub. year": 2014.0000
          }
        },
        {
          "id": 114,
          "label": "control systems",
          "x": -0.3014,
          "y": 0.0479,
          "cluster": 1,
          "weights": {
            "Links": 6.0000,
            "Total link strength": 51.0000,
            "Occurrences": 35.0000
          },
          "scores": {
            "Avg. pub. year": 2015.8857
          }
        },
        {
          "id": 159,
          "label": "dynamical systems",
          "x": 0.0573,
          "y": -0.0635,
          "cluster": 1,
          "weights": {
            "Links": 6.0000,
            "Total link strength": 50.0000,
            "Occurrences": 34.0000
          },
          "scores": {
            "Avg. pub. year": 2015.3529
          }
        },
        {
          "id": 160,
          "label": "education",
          "x": -0.0599,
          "y": -0.7391,
          "cluster": 4,
          "weights": {
            "Links": 3.0000,
            "Total link strength": 16.0000,
            "Occurrences": 8.0000
          },
          "scores": {
            "Avg. pub. year": 2016.2500
          }
        },
        {
          "id": 175,
          "label": "embedded systems",
          "x": -0.1198,
          "y": 0.8091,
          "cluster": 3,
          "weights": {
            "Links": 3.0000,
            "Total link strength": 9.0000,
            "Occurrences": 4.0000
          },
          "scores": {
            "Avg. pub. year": 2019.7500
          }
        },
        {
          "id": 456,
          "label": "robotics",
          "x": -0.9731,
          "y": -0.1087,
          "cluster": 1,
          "weights": {
            "Links": 2.0000,
            "Total link strength": 6.0000,
            "Occurrences": 3.0000
          },
          "scores": {
            "Avg. pub. year": 2011.6667
          }
        },
        {
          "id": 481,
          "label": "signal processing",
          "x": 0.8898,
          "y": -0.1632,
          "cluster": 2,
          "weights": {
            "Links": 3.0000,
            "Total link strength": 8.0000,
            "Occurrences": 9.0000
          },
          "scores": {
            "Avg. pub. year": 2016.0000
          }
        }
      ],
      "links": [
        {
          "source_id": 90,
          "target_id": 114,
          "strength": 11.0000
        },
        {
          "source_id": 90,
          "target_id": 159,
          "strength": 10.0000
        },
        {
          "source_id": 90,
          "target_id": 160,
          "strength": 2.0000
        },
        {
          "source_id": 90,
          "target_id": 175,
          "strength": 1.0000
        },
        {
          "source_id": 90,
          "target_id": 481,
          "strength": 2.0000
        },
        {
          "source_id": 114,
          "target_id": 159,
          "strength": 23.0000
        },
        {
          "source_id": 114,
          "target_id": 160,
          "strength": 8.0000
        },
        {
          "source_id": 114,
          "target_id": 175,
          "strength": 4.0000
        },
        {
          "source_id": 114,
          "target_id": 456,
          "strength": 3.0000
        },
        {
          "source_id": 114,
          "target_id": 481,
          "strength": 2.0000
        },
        {
          "source_id": 159,
          "target_id": 160,
          "strength": 6.0000
        },
        {
          "source_id": 159,
          "target_id": 175,
          "strength": 4.0000
        },
        {
          "source_id": 159,
          "target_id": 456,
          "strength": 3.0000
        },
        {
          "source_id": 159,
          "target_id": 481,
          "strength": 4.0000
        }
      ]
    }
  };
</script>
<script>
  // Constantes de lógica de negocio
  const ANCHO_CUADRANTE = 250;
  const COLORES = {
    1: "#FA8072",
    2: "#A52A2A",
    3: "#20B2AA",
    4: "#FF8C00",
    5: "#FFFF00",
    6: "#8A2BE2",
    7: "#7CFC00",
    8: "#00FF7F",
    9: "#FF6347",
    10: "#778899",
    11: "#FF69B4",
    12: "#1E90FF",
  };
</script>
<script>
  // Funciones auxiliares
  function determinarCuadrante(x, y) {
    if(x<ANCHO_CUADRANTE) {
      return y<ANCHO_CUADRANTE ? "SEGUNDO-CUADRANTE" : "TERCER-CUADRANTE";
    } else if (x>ANCHO_CUADRANTE) {
      return y<ANCHO_CUADRANTE ? "PRIMER-CUADRANTE" : "CUARTO-CUADRANTE";
    }
  }

  function ajustarBordesDeEnlace(div, x1, x2, y1, y2, ancho) {
    const cuadranteNodo1 = determinarCuadrante(x1,y1);
    const cuadranteNodo2 = determinarCuadrante(x2,y2);
    if( cuadranteNodo1==="PRIMER-CUADRANTE" &&
        cuadranteNodo2==="SEGUNDO-CUADRANTE" ){
      if(y1<y2) {
        div.style.border = "solid";
        div.style.borderColor = "black";
        div.style.borderWidth = "0px "+ancho.toString()+"px "+ancho.toString()+"px "+" 0px";
      } else {
        div.style.border = "solid";
        div.style.borderColor = "black";
        div.style.borderWidth = concat(
          ancho.toString()+"px ",
          ancho.toString()+"px ",
          " 0px ",
          " 0px");
      }
    } else if( cuadranteNodo1==="SEGUNDO-CUADRANTE" &&
        cuadranteNodo2==="PRIMER-CUADRANTE" ){
      if(y1<y2) {
        
      }
    }
  }

  function obtenerCoordenadasNodo(cantidad, contador, eje, label) {
    // Dividimos la circunferencia unitaria en partes 
    // iguales y hallamos la coordenada del punto segun el 
    // contador
    const ANGULO = (360/cantidad)*contador;
    let porcentaje = eje==="y" ? Math.sin(ANGULO) : Math.cos(ANGULO);
    let posicion = ANCHO_CUADRANTE*porcentaje;
    posicion = posicion<0 ? posicion*-1 : posicion;
    let posicionAjustada = 0;
    if( eje==="x" ){
      posicionAjustada = porcentaje<0 ? ANCHO_CUADRANTE-posicion : ANCHO_CUADRANTE+posicion;
    } else if( eje==="y" ){
      posicionAjustada = porcentaje<0 ? ANCHO_CUADRANTE+posicion : ANCHO_CUADRANTE-posicion;
    };
    return posicionAjustada;
  };
</script>
<script>
  // Lógica de negocio
  let RED = undefined;
  switch(grupo.toString()){
    case "IDEAS - Investigación, Desarrollo y Aplicaciones en Señales":
      RED = IDEAS.network;
  };

  const CONTENEDOR = document.querySelector(".contenedor");
  const CANTIDAD_ITEMS = RED.items.length;
  let contador = 1;
  RED.items.forEach(nodo => {
    const span = document.createElement("span");
    const p = document.createElement("p");
    span.id = "nodo-"+nodo.id.toString();
    span.className = "nodo";
    p.textContent = nodo.label;
    p.style.textAlign = "center";
    p.style.position = "absolute";
    span.style.position = "absolute";
    const left = obtenerCoordenadasNodo(CANTIDAD_ITEMS, contador, "x", nodo.label).toString().concat("px");
    const top = obtenerCoordenadasNodo(CANTIDAD_ITEMS, contador, "y", nodo.label).toString().concat("px");
    span.style.left = left;
    p.style.left = left;
    span.style.top = top;
    p.style.top = top;
    p.style.maxWidth = "50px";
    span.style.width = (nodo.weights.Occurrences).toString()+"px";
    span.style.height = (nodo.weights.Occurrences).toString()+"px";
    span.style.borderRadius = "100%";
    span.style.cursor = "default";
    p.style.cursor = "default";
    span.style.backgroundColor = COLORES[nodo.cluster];
    CONTENEDOR.appendChild(span);
    CONTENEDOR.appendChild(p);
    contador++;
  });

  RED.links.forEach(enlace => {
    const primeraLinea = document.querySelector("#nodo-"+enlace.source_id.toString());
    const segundaLinea = document.querySelector("#nodo-"+enlace.target_id.toString());
    if(!primeraLinea || !segundaLinea)
      window.location.reload();

    const x1 = primeraLinea.offsetLeft;
    const y1 = primeraLinea.offsetTop;
    const x2 = segundaLinea.offsetLeft;
    const y2 = segundaLinea.offsetTop;

    let ancho = x2-x1;
    ancho = ancho<0 ? ancho*-1 : ancho;
    let alto = y2-y1;
    alto = alto<0 ? alto*-1 : alto;

    const div = document.createElement("div");
    div.style.width = ancho.toString()+"px";
    div.style.height = alto.toString()+"px";
    div.style.position = "absolute";
    div.style.top = (y1<y2 ? y1 : y2).toString()+"px";
    div.style.left = (x1<x2 ? x1 : x2).toString()+"px";
    ajustarBordesDeEnlace(div, x1, x2, y1, y2, enlace.strength)

    CONTENEDOR.appendChild(div);
  });
</script>
</html>